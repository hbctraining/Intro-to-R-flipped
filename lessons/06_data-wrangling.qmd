---
title: "Data Wrangling: Subsetting vectors and factors"
description: |
  This lesson will show participants how to subset vectors and factors in R using indices, sequences and logical operators. This lesson also introduces the `which()` function and demonstrates how to relevel factor variables for clearer data analysis.
author:
  - Mary Piper
  - Meeta Mistry
  - Radhika Khetani
  - Will Gammerdinger
  - Noor Sohail
date: "2025-05-30"
categories: 
  - R Programming
  - Data Wrangling
keywords:
  - R
  - vectors
  - factors
  - subsetting
  - logical operators
  - indexing
  - which
  - releveling factors
license: "CC-BY-4.0"
editor_options: 
  markdown: 
    wrap: 72
---

Approximate time: 40 min

```{r}
#| label: load_data
#| echo: false
# Create a character vector and store the vector as a variable called 'expression'
expression <- c("low", "high", "medium", "high", "low", "medium", "high")
expression <- factor(expression)
test <- c(1, NA, 2, 3, NA, 4)
```

## Learning Objectives

* Demonstrate how to subset vectors and factors
* Explain the use of logical operators when subsetting vectors and factors
* Demonstrate how to relevel factors in a desired order


## Selecting data using indices and sequences

When analyzing data, we often want to **partition the data so that we are only working with selected columns or rows.** A data frame or data matrix is simply a collection of vectors combined together. So let's begin with vectors and how to access different elements, and then extend those concepts to dataframes.

### Vectors

#### Selecting using indices

If we want to extract one or several values from a vector, we must provide one or several indices using square brackets `[ ]` syntax. The **index represents the element number within a vector** (or the compartment number, if you think of the bucket analogy). R indices start at 1. Programming languages like Fortran, MATLAB, and R start counting at 1, because that's what human beings typically do. Languages in the C family (including C++, Java, Perl, and Python) count from 0 because that's simpler for computers to do.

Let's start by creating a vector called age:

```{r}
#| label: create_age
# Create a vector with some random ages and assign it to age 
age <- c(15, 22, 45, 52, 73, 81)
```

![](../img/vector-index.png)

Suppose we only wanted the fifth value of this vector, we would use the following syntax:

```{r}
#| label: age_fifth
# Extract the fifth value from the age vector
age[5]
```

If we wanted all values except the fifth value of this vector, we would use the following:

```{r}
#| label: age_all_but_fifth
# Extract all of the values except for the fifth value from the age vector
age[-5]
```

If we wanted to select more than one element we would still use the square bracket syntax, but rather than using a single value we would pass in a *vector of several index values*:

```{r}
#| label: age_vector_subset
# Use a nested approach to extract multiple values from the age vector
age[c(3,5,6)]   

# Or create an index vector first for the indices to extract from then age vector
idx <- c(3,5,6) 
# Then extract the ages from the age vector using the index vector
age[idx]
```

To select a sequence of continuous values from a vector, we would use `:` which is a special function that creates numeric vectors of integer in increasing or decreasing order. Let's select the *first four values* from age:

```{r}
#| label: age_sequence_subset
# Extract the first four ages from the age vector
age[1:4]
```

Alternatively, if you wanted the reverse could try `4:1` for instance, and see what is returned. 

::: {.callout-tip}
# [**Exercise 1**](06_data-wrangling-Answer_key.qmd#exercise-1)

1. Create a vector called `alphabets` with the following letters, C, D, X, L, F.

2. Use the associated indices along with `[ ]` to do the following:
	* Only display C, D and F
	* Display all except X
	* Display the letters in the opposite order (F, L, X, D, C)
:::

#### Selecting using indices with logical operators

We can also use indices with logical operators. Logical operators include greater than (`>`), less than (`<`), and equal to (`==`). A full list of logical operators in R is displayed below:

| Operator | Description |
| :-----------:|:----------------|
| > | greater than |
| >= | greater than or equal to|
| < | less than |
| <= | less than or equal to |
| == | equal to |
| != | not equal to |
| & | and |
| \| |or |

We can use logical expressions to determine whether a particular condition is true or false. For example, let's use our age vector: 
	
```{r}
#| label: print_age
# Show the age vector
age
```

If we wanted to know if each element in our age vector is greater than 50, we could write the following expression:	

```{r}
#| label: age_greater_than_50
# Return a logical vector for values in age greater than 50
age > 50
```

Returned is a vector of logical values the same length as age with TRUE and FALSE values indicating whether each element in the vector is greater than 50.

We can use these logical vectors to select only the elements in a vector with TRUE values at the same position or index as in the logical vector.

Select all values in the `age` vector over 50 **or** `age` less than 18:

```{r}
#| label: age_greater_than_50_less_than_18
# Return a logical vector for values in age greater than 50 or less than 18
age > 50 | age < 18

# Use a nested approach to extract values from the age vector greater than 50 or less than 18
age[age > 50 | age < 18]

# Or create a logical vector for values in age greater than 50 or less than 18
idx <- age > 50 | age < 18
# Then extract the ages from the age vector using the index vector
age[idx]
```

##### Indexing with logical operators using the `which()` function

While logical expressions will return a vector of TRUE and FALSE  values of the same length, we could use the `which()` function to output the indices where the values are TRUE. Indexing with either method generates the same results, and personal preference determines which method you choose to use. For example:

```{r}
#| label: age_greater_than_50_less_than_18_which
# Return the indicies for the values in age which are greater than 50 or less than 18
which(age > 50 | age < 18)

# Use a nested approach to extract indicies from the age vector where the values are greater than 50 or less than 18
age[which(age > 50 | age < 18)]

# Or create an index vector for indices from the age vector where the values are greater than 50 or less than 18
idx_num <- which(age > 50 | age < 18)
# Then extract the ages from the age vector using the index vector
age[idx_num]
```

Notice that we get the same results regardless of whether or not we use the `which()`. Also note that while `which()` works the same as the logical expressions for indexing, it can be used for multiple other operations, where it is not interchangeable with logical expressions.

::: {.callout-note}
It should also be noted that `which()` and logical operators alone handle `NA` values differently. When R encounters an `NA` value while subsetting using just logical operators, it will retain that value. However, when we use `which()`, R will omit `NA` values. Let's observe this behavior using our `test` object from earlier: 

```{r}
#| label: print_test
# Print test object
test

# Subset test just using a logical operator
# NA values retained
test[test > 1]

# Subset test using which() around a logical operator
# NA values discarded
test[which(test > 1)]
```

This can be particularly useful if the dataset you are subsetting has `NA` values in it and you are wrapping your subsetting into a `length()` function to get the number of elements that pass that filtering. You may not want to include `NA` values in that count. If so, you will want to wrap your subsetting in a `which()` function prior to passing it to `length()`.

:::

### Factors

Since factors are special vectors, the same rules for selecting values using indices apply. The elements of the expression factor created previously had the following categories or levels: low, medium, and high. 

Let's extract the values of the factor with high expression, and let's using nesting here:

```{r}
#| label: subset_expression
# Return the values in the expression factor vector equal to "high"
expression[expression == "high"]    
```

::: {.callout-note}
# Nesting note: 
The piece of code above was more efficient with nesting; we used a single step instead of two steps as shown below:

 * Step1 (no nesting): `idx <- expression == "high"`
 * Step2 (no nesting): `expression[idx]`
:::

::: {.callout-tip}
# [**Exercise 2**](06_data-wrangling-Answer_key.qmd#exercise-2)

Extract only those elements in `samplegroup` that are not KO (*nesting the logical operation is optional*).
:::

#### Releveling factors

We have briefly talked about factors, but this data type only becomes more intuitive once you've had a chance to work with it.  Let's take a slight detour and learn about how to **relevel categories within a factor**. 

To view the integer assignments under the hood you can use `str()`:

```{r}
#| label: structure_expression
# Show the expression factor vector
expression

# Return the structure of the expression factor vector
str(expression)
```

The categories are referred to as "factor levels". As we learned earlier, the levels in the `expression` factor were assigned integers alphabetically, with high=1, low=2, medium=3. However, it makes more sense for us if low=1, medium=2 and high=3, i.e. it makes sense for us to "relevel" the categories in this factor.

To **relevel the categories**, you can add the `levels` argument to the `factor()` function, and give it a vector with the categories listed in the required order:

```{r}
#| label: structure_refactored_expression
# Re-level the expression factor vector 
expression <- factor(expression, levels=c("low", "medium", "high"))     

# Return the updated structure of the expression factor vector
str(expression)
```

Now we have a releveled factor with low as the lowest or first category, medium as the second and high as the third. This is reflected in the way they are listed in the output of `str()`, as well as in the numbering of which category is where in the factor.

::: {.callout-note}
Releveling becomes necessary when you need a specific category in a factor to be the "base" category, i.e. category that is equal to 1. One example would be if you need the "control" to be the "base" in a given RNA-seq experiment.
:::

::: {.callout-tip}
# [**Exercise 3**](06_data-wrangling-Answer_key.qmd#exercise-3)
Use the `samplegroup` factor we created in a previous lesson, and relevel it such that KO is the first level followed by CTL and OE. 
:::
